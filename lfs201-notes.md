# LFS201
## Notes by Jeremiah Richter

### 1. Course Introduction

  * Use LFS101x.2 as reference
  * notes for that course located [here](./lfs101-notes.md "lfs101-notes")
  * two levels, **LFCS** and **LFCE**
  * find **domains** and **competencies** [here](http://training.linuxfoundation.org/certification)
  * only most common options listed
  * for x86-based machines, assuming 64-bit
  * focus on **Enterprise Linux** distros, like:
    * **RHEL** (RED HAT ENTERPRISE LINUX)
    * **SUSE**
    * **Ubuntu**, probably 14.04 LTS release
    * virtual install recommended to avoid damage to a working installation
  * 12 months access to course
  * There are labs and exercises with answer solutions, but they are not
    graded, no final exam
  * `Gnome` is focused on because of the larger user base, not because of a
    preference
  * **Linux Foundation** is a non-profit consortium dedicated to fostering the
    growth of Linux. It sponsors the work of Linus Torvalds, organizes LinuxCon,
    manages the Linux trademark, and supports the Linux Standards Base

### 2. System Startup and Shutdown

  * boot sequence steps:
    1. **BIOS/UEFI** locates and executes the boot program/loader
    2. the boot loader loads the kernel
    3. the kernel starts the `init` process (`pid=1`)
    4. `init` manages system usage using **SysVinit** startup scripts, or
      using **Upstart** or **systemd**
  * the **BIOS** loads the boot loader from the **MBR**
  * boot loaders:
    ```
    GRUB (most common)
    LILO (obsolete)
    efilinux (for UEFI)
    Das U-Boot (embedded)
    ```
  * config files are in `/etc`:
    * Debian uses `/etc/default`
    * RHEL uses `/etc/sysconfig`
    * Newer Redhat-based and SUSE use both
    * scripts in `/etc/init.d/` may use environmental variables from
      `/etc/sysconfig` or `/etc/default`
  * `shutdown` halts or reboots the system:
    * `-h +num/now [message]`: power off, must be followed by a `+num` for 'num'
      minutes in the future, `now` for now, and an optional `message`
    * `-r`: reboots the system
    * `-k`: just sends a message to logged-in users, no shutdown
    * `-c`: cancel pending shutdown
  * `reboot/halt/poweroff`: legacy equivalents

### 3. GRUB

  * **G** rand **U** nified **B** oot **L** oader
  * older systems use `GRUB 1`, newer systems have migrated to `GRUB 2`
  * `/boot/grub/grub.cfg` or `/boot/grub2/grub.cfg` for `GRUB 2` are read at boot,
    auto-generated by `update-grub` (or `ugrub2-mkconfig` on **RHEL**) based on
    files in `/etc/grub.d/` and `/etc/default/grub`, but the latter should not be
    hand-edited
  * `/boot/grub/grub.conf` and `/boot/grub/menu.lst` are config files for `GRUB 1`
    but shouldn't be hand-edited. `grubby` in **RHEL** 5-7 is normally used
  * once booted to the `GRUB` menu, `e` can be pressed to edit an entry
  * `GRUB 2` install with `sudo grub2-install /dev/file`
  * `GRUB 1` install with `grub-install` or `sudo grub` to enter `grub` prompt, then:
    ```
    >root (hd0,0)
    >setup (hd0)
    >exit
    ```
  * in version 1, hard drives are `hd0`, `hd1`, etc, and partitions start at 0
  * in version 2, hard drives are `hd0`, `hd1`, etc, and partitions start at 1
  * the *root* partition, in `GRUB` lingo, is the partition the kernel is
    stored, i.e.: in the `/boot` directory

### 4. init: SystemV, Upstart, Systemd

  * `/sbin/init`: first user-level process run on the system and runs until
    shutdown, configures environment, starts login process
  * **SysVinit** was for multi-user mainframes, single processor, each stage must
    complete before next stage of startup could begin, *serial* process
  * **Upstart** was developed in 2006 by Ubuntu
  * **Systemd** is more recent, adopted first by Fedora in 2011
    * is now default for every major Linux distros
  * `sysvinit`-compatibility layers will persist for the foreseeable future
    * `sysvinit` passes through various *runlevels*, or stages, which define
      different states, numbered 0-6, here are Red Hat's runlevels:
      ```
      0 system halt state
      1 single-user mode
      2 distro-defined (multi-user without networking)
      3 distro-defined (multi-user with networking, CLI)
      4 distro-defined (not used)
      5 distro-defined (multi-user, usually X and networking)
      6 reboot
      s same as 1
      ```
    * `runlevel` displays previous and current runlevel, `N` is unknown runlevel
    * `telinit 'runlevel'`: changes runlevel to 'runlevel'
    * `/etc/inittab`: traditionally told `init` which scripts to run at which
      runlevel, lines are written `id:runlevel:action:process`:
      ```
      id:       1-4 chars, unique, for each entry
      runlevel: zero or more chars/digits to identify runlevel
      action:   action to take
      process:  process to be executed
      ```
      in Red Hat there is only the one line `id:5:initdefault`, which states the
      default runlevel
    * `/etc/rc.sysinit` script would mount filesystems, etc., this was usually a
      symbolic link to `/etc/rc.d/{somefile}`, then `/etc/rc` script was run with
      desired runlevel as an argument. The system would then look in
      `/etc/rc.d/rc[0-6].d/` and run the scripts in there
    * `/etc/rc.local` would start system-specific scripts
    * Note:
      * all startup scripts are in `/etc/init.d/`; each runlevel links to them
      * **start** scripts start with an **S**
      * **kill** scripts begin with an **K**
      * script's name is then the name of the service, one manages scripts by
        managing links, can be manual or with `chkconfig`
    * `chkconfig servicename`: check if set to run in current runlevel
    * `chkconfig --list [service_names]`: what services in which runlevels
    * `sudo chkconfig service on`: enables service to run on next boot
    * `sudo chkconfig service off`: reverses the above
    * `sudo chkconfig service [start | stop]`: starts/stops service now without
      reboot
    * add script with certain lines to `/etc/init.d/`, run `chkconfig --add` to
      enable, `chkconfig --del` to disable
        * example line: `# chkconfig 2345 10 90` runs in 2-5 runlevels, starts
        with priority `S10` script, ends with `590` script
    * `sudo service 'service' status` command would check service status of
      script in `/etc/init.d/`
    * `sudo service 'servicename' {start|stop|restart|reload|status}` are the
      usual options
    * `sudo service --status-all` for all services
    * recent versions of Ubuntu won't use `chkconfig`:
      * `sudo invoke-rc.d service [status|start|stop]` or `sudo status 'service'`
      * `sudo update-rc.d 'service' [defaults|purge]`
      * `sudo sysv-rc-conf 'service' [on|off]`
  * `Upstart` is *event-driven*, rather than serial; events are sent to `init` to
    tell it to execute certain commands when prerequisites are met; superseded by
    `systemd`, config files:
    ```
    /etc/init/rcS.conf
    /etc/rc-sysinit.conf
    /etc/inittab
    /etc/init/rc.conf
    /etc/rc[0-6].d
    ```
    * kernel starts `init`, which starts `rcS.conf`, which runs `rc-sysinit.conf`
    * `rc-sysinit.conf` will do startup tasks, like LVM and filesystems, then run
      the `/etc/inittab` runlevel. This runlevel is sent to script `rc.conf`.
      Additional scripts, like `prefdm.conf` for runlevel 5, are run.
    * Upstart events are found in `/etc/event.d`, startup jobs are in `/etc/init`
    * `initctl` is like service, use `initctl options command`, options are:
      ```
      start: starts a job
      stop: stops a job
      restart: restart a job
      reload: sends HUP signal to job
      status: gets job status
      list: list known jobs
      emit: emit an event
      ```
  * `systemd` is backwards-compatible with `sysvinit` and uses *targets* to emulate
    runlevels, emulates `telinit`, socket and D-Bus activation, *parallel* startup,
    doesn't need shell scripts, uses *cgroups*, can mount/unmount, can be drop-in
    replacement for `sysvinit`
    * uses `.service` files to delineate services
    * standard config files:
    ```
    /etc/vconsole.conf: default keymapping and console Foundation
    /etc/sysctl.d/*.conf: drop-in directory for kernel sysctl parameters
    /etc/os-release: distro ID file
    ```
    * `systemctl` is main utility for service management:
      * `systemctl [options] command [name]`: usage
      * `systemctl list-units -t service`: list active services
      * `sudo systemctl [start|stop] 'service'`: start/stop unit
      * `sudo systemctl [enable|disable] 'service'`: enable/disable unit

### 5. Linux Filesystem Tree Layout

  * files/folders are organized between *sharable/non-sharable* and *variable/static*
    * *sharable* files can be shared across hosts
    * *static* files don't change without administrator intervention,       
      *variable* files might change on their own
  * **FHS** or **F** ile **H** ierarchy **S** tandard is administered by
    the **Free Standards Group** and now the **Linux Foundation**, specifies  
    what directories need to be present and purpose, not followed exactly
  * no package should make new root directories
  * `/boot` essential files for booting:
    * `vmlinuz`: compressed linux kernel
    * `initramfs`: initial RAM filesystem, mounted before real root filesystem  
    becomes available
    * `config`: config file for kernel compilation
    * `System.map`: kernel symbol table, used for debugging
  * `/dev` holds device files, also called *nodes*, respresent devices connected  
    to the system, network devices have names like `eth1` or `wlan0`
    * modern systems use `udev`, which creates device nodes when devices are  
      added or connected
  * `/home` contains users' files and directories, and sometimes groups
    * `$HOME`: shell environmental variable that contains the current user's  
      home directory path, aliased to `~`
    * root's home directory resides at `/root`
  * `/media`: automounted media are mounted under here, being replaced by  
    `/run/media/[username]`
  * `/mnt`: temporary mount point for `NFS`, `Samba`, `CIFS` and `AFS`
  * `/opt`: for software packages that don't want files scattered throughout  
    the filesystem
  * `/proc`: pseudo-filesystem in memory with kernel data structures and  
    processes
    * `/proc/interrupts`, `/proc/meminfo`, `/proc/mounts`, `/proc/partitions`  
    are up-to-date views of hardware
    * `/proc/filesystems` and `/proc/sys/` provide system config and interfaces
    * `/sys`: mount point for `sysfs`, in-memory, provides system info  
      and can modify system values
  * `/tmp`: for temp files, accessed by any user/app, are deleted by `cron`
    jobs, reboots, sometimes is a `ramfs`
  * `/usr` is a **secondary hierarchy**, for files not needed for booting  
    can be mounted over the network
    * software packages shouldn't create subdirectories under `/usr`
    * typically read-only data, may have binaries not used in single-user  
      mode
    * `/usr/share/man`: where `man` pages are stored
  * `/var` contains *variable*, or *volatile* data files that change
    frequently during system operation:
    * log files
    * spool files for printing/mail queues
    * admin data files
    * cache contents
    * for security reasons `/var` is often a separate filesystem
    * `/var/log`: most of the log files are here
    * `/var/spool`: local files for mail/printing/cron jobs
  * `/run` is new directory tree used by many major
    * not officially accepted by the **FHS**
    * is to store transient files and runtime info
    * usually an empty mount point with `tmpfs` ram disk like
      `/dev/shm` mounted there at runtime
    * `/var/run`, `/var/lock` can be symbolic links under `/run`,  
      among others
  * `/lib`: libraries for binaries in `/bin` and `/sbin`
    * kernel modules are often under `/lib/modules/<kernel-version-number>`
    * **PAM** (**P** luggable **A** uthentication **M** odules) are  
      stored under `/lib/security`
    * `/lib64` may exist to separate 32-bit and 64-bit libraries if  
      they exist side-by-side
  * `/bin`: executables and scripts for system admins and users  
    that are required before mounting other filesystems, like in  
    single-user or recovery mode
    * no subdirectories
    * some non-essential binaries go into `/usr/bin`
  * `/sbin` has binaries essential for booting, restoring, recovering  
    or repairing, must be able to mount
  * recent distros have been combining `/bin` and `/sbin` into their  
    `/usr` versions and sym-linking back to their root locations

### 6. Kernel Services and Configuration
  * Narrowly defined, **Linux** is only the **kernel** of the operating system,  
    which contains libraries and applications that interact with the **kernel**
  * the **kernel** connects the hardware to the software and manages system  
    resources, handles device drivers
  * parameters can be passed on the **kernel command line**, usually on the  
   `kernel` line of the `GRUB` config file (or `linux16` line)
    * to view these parameters use `cat /proc/cmdline`
    * kernel parameters can be found in kernel source under
      `Documentation/kernel-parameters.txt`
    * at http://kernel.org/doc/Documentation/kernel-parameters.txt
    * possibly with a package called `kernel-doc` or `linux-doc`
    * under `man bootparam`
      ```
      ro: mount root device as read-only
      root: root filesystem
      rd_LVM_LV: activate root filesystem in the logical volume specified
      rd_NO_LUKS: disables LUKS detection
      rd_NO_DM: disables DM RAID detection
      LANG: system language
      SYSFONT: console font
      KEYTABLE: keytable filename
      ```
        * *Note*: `rd`- prefixed options are usually only for RedHat distros
  * `sysctl`: used to read and tune kernel parameters at runtime
    * `sysctl -a`: list all options; each option corresponds with pseudofiles
      under `/proc/sys/`, with directory slashes being replaced by dots
    * `sysctl path.to.pseudofile=value`
    * settings can be made persistent across reboots by adding the settings to
      `/etc/sysctl.conf`, can be purged with `sudo sysctl -p`, sometimes the  
      file is in `/usr/lib/sysctl.d/00-system`

### 7. Kernel Modules

  * **modules** are pieces of software the kernel can load/unload at runtime,
    like device drivers or network protocols or filesystems; they can take
    parameters
  * **Linux** still maintains a *monolithic* kernel architecture, not a
    *microkernel*, as a loaded module is fully functional and uses shared  
    resources and locks, instead of messages
  * `lsmod`: list loaded modules
  * `insmod`: directly load modules
  * `rmmod`: directly remove modules
  * `modprobe`: load/unload modules using database with dependency info
  * `depmod`: rebuild the module database
  * `modinfo`: display module info
  * `sudo insmod /path/to/module_name.ko`: load a module by path and filename
  * normally, modules are found at `/lib/modules/<kernel-version-number>`
  * `sudo rmmod module_name` will remove a module from memory
  * mostly one can use `sudo modprobe module_name` and `sudo modprobe -r
    module_name` (for removal)
    * modules used by other running modules cannot be unloaded, or being used by
      running processes
    * using `modprobe` will load dependent modules, as well
  * `modinfo module_name` shows version name, filename, hardware devices
    handled, and what parameters can be supplied on loading
  * much of `modinfo`'s info can be found under `/sys/module`
  * modules can be loaded with parameter values like `modprobe e1000e debug=2
    copybreak=256`
  * files in `/etc/modprobe.d/` control some parameters when `modprobe`

### 8. Devices and udev

  * character and block devices have filesystem entries; network devices do not.
  * a device driver may manage more than one device node under `/dev`
  * **major** and **minor** numbers identify the driver associated with the  
    device; the **minor** number is used by the device driver to differentiate
    between different devices controlled by the same driver
  * `udev` automates the creation of device nodes based on `udev rules`
  * `udev` runs as a daemon, either `udevd` or `systemd-udevd` which monitors a
    **netlink** socket, which the kernel `uevent` uses to send a message to `udev`
    and creates a device node based on rules
  * three components are:
    * `libudev` allows access to hardware info
    * `udevd` daemon maintains the `/dev` directory
    * `udevadm` for control and diagnosis
  * for a system without device nodes on boot, `initramfs` will have to have basic
    device nodes
  * `udev` works with hotplug system to use info in `/sys` `sysfs` system and  
    in config files:
    * main config file is `/etc/udev/udev.conf` and contains info on where to  
      place device nodes, default permissions, etc.
    * `/etc/udev/rules.d/` contains the default rules, which is scanned every  
      event from kernel about hardware is received
      * the files are named like `30-usb.rules` or `90-mycustom.rules`
      * format for udev rule:
        ```
        <match><op>value [, ...] <assignment><op>value [, ...]
        ```
        where the first part consists of match pairs with `==`, the second part
        with key-value pairs that assign values to names, like file name,
        permissions
      * example:
      ```
      KERNEL=="fuse", MODE="0666", OWNER="root", GROUP="root"
      ```

### 9. Partitioning and Formatting Disks

  * rotational media have `heads`, which read `tracks`, groups of which are
    called `cylinders` when they are in the same location on all platters,  
    which are separated into `sectors`, mostly **512** bytes but can be  
    **4096**
  * disks may be divided into contiguous sectors/cylinders or `partitions`
  * with **M** aster **B** oot **R** ecord, there can be **4** primary  
    partitions, one of which can be an *extended* partition, which can be  
    sub-divided until the max partition limit is reached (usually **15**)
  * **Linux** does not require partitions to begin/end on cylinder boundaries,
    but will try to play nice with other OSes and do this
  * there are reasons to partition:
        Separation, like `/home` on own partition
        Sharing, like between other OSes
        Security, like quotas for different parts of the system
        Size, as some data are constant, and some grow, like the `/var` folder
        Performance, like near the center of a platter
        Swap, as Linux likes to have a separate swap partition
  * the **MBR** contains the partition table, is **512 bytes** in length
    * the partition table is **64 bytes** long and placed after the **446
      byte** boot record, which has program code, usually the boot loader.
    * only one partition may be marked as active, where boot loader looks for
      items to load
    * each entry on partition table is 16 bytes long, describing one of four  
      possible partitions, containing:
      * active bit
      * beginning address in cylinder/heads/sectors format (ignored by  
        **Linux**)
      * partition type code (`xfs`, `LVM`, `ntfs`, `swap`, etc.)
      * ending address in **CHS** format (ignored by **Linux**)
      * start sector counting from zero
      * number of sectors in partition
    * Linux uses the last two fields for **L** ogical **B** lock  
    **A** ddressing (**LBA**)
  * device nodes are usually accessed through Linux's **VFS** or **V** irtual
    **F** ile **S** ystem; writing to device nodes directly is dangerous
  * **SCSI** and **SATA** drives follow simple naming scheme: `/dev/sd{a,b,c,...}`
    with partitions being numbered suffixes, eg: `/dev/sda1`
  * **SCSI** devices are enumerated by controller # (a,b,c part) then device #
    (1,2,3 part)
  * `blkid` is a utility to locate block devices and report on their attributes
    * uses `libblkid`
    * can take a device as an argument
    * only works on non-empty partition
  * `lsblk` lists block devices in a tree format
  * Linux systems should use a minimum of two partitions:
    * `/` but there are usually more mount points under root for data security
      and easy backup
    * `swap`: used as extension of physical memory; non-file-mapped pages are
      moved to disk until needed
  * backup of **MBR**: `sudo dd if=/dev/sda of=mbrbackup bs=512 count=1`
  * restore **MBR**: `sudo dd if=mbrbackup of=/dev/sda bs=512 count=1`
  * `fdisk`: menu-driven partition editor
  * `sfdisk`: non-interactive `fdisk` for scripting
  * `parted`: **GNU** partition program
  * `gparted`: **GTK** frontend for `parted`
  * `fdisk` commands:
    ```
    m: display the menu
    p: print the partition
    n: new partition
    d: delete a partition
    t: change a partition type
    w: write the partition table info
    q: quit without saving changes
    ```
    * can use `sudo partprobe -s` to re-read partition table, but best to  
      reboot

### 10. Encrypting Disks

  * Most Linux distros offer block-level encryption using **LUKS** (**L** inux  
    **U** nified **K** ey **S** etup), highly recommended for laptops/smartphones
  * **LUKS** is installed on top of `cryptsetup`,which uses the `dm-crypt`  
    kernel module, which uses `device mapper` used by **LVM** as well
  * **LUKS** stores info in partition header, so is easy to migrate to other  
    systems
  * `cryptsetup [option...] <action> <action-specific>`: usage
  * for example `LVM` partition `/dev/VG/MYSECRET`:
    * `sudo cryptsetup luksFormat /dev/VG/MYSECRET`to enable `LUKS` and set  
      passphrase
    * use `cat /proc/crypto` to ciphers supported, use `--cipher` option to   
      specify which one to use a different one
    * `sudo cryptsetup --verbose luksOpen /dev/VG/MYSECRET` to open partition
    * `sudo mkfs.ext4 /dev/mapper/SECRET` to format
    * `sudo mount /dev/mapper/SECRET /mnt` to mount
    * `sudo umount /mnt` to unmount
    * `sudo cryptsetup --verbose luksClose SECRET` to remove from mapper
  * to mount at boot:
    1. make an entry in `/etc/fstab`
    2. add an entry to `/etc/crypttab`
            SECRET  /dev/mapper/MYSECRET
### 11. Linux Filesystems and the VFS
  * **VFS** is an abstraction layer (<b>V</b>irtual <b>F</b>ile <b>S</b>ystem)  
    that stands between the software and the on-disk file system
  * *raw* writing to disk (ignoring the filesystem) is dangerous
  * filesystems can be on hard disk partitions, `LVM`s or on a network drives
  * multiple filesystems can be mounted under a root partition at a mount point
  * some mounted filesystems are virtual(`/proc`, `/sys`, `/dev`)
  * the **VFS** sits between the reading/writing I/O system calls and the hardware
    and handles the location and hardware
  * some filesystems don't have full user permissions and the **VFS** must add
    them
  * some filesystem drivers exist outside the kernel, but kernel-mode is faster
  * **journaling** filesystems recover from crashes with little to no corruption
    * they use transactions, meaning writes/updates occur **atomically**
    * there is a log file of transactions
  * `cat /proc/filesystems` => list of supported kernel filesystems
  * `tmpfs` is better than a `ramdisk` because it can be swapped, it uses  
    memory more efficiently, and doesn't need to be formatted before use
